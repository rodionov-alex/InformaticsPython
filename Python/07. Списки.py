print('-=-=-= СПИСКИ =-=-=-')

A = list()                  # Пустой список
A = []                      # Пустой список
A = [6, 4, 5, 8, 7]         # Список A, проинициализированный элементами 6, 4, 5, 8, 7
B = [i for i in range(10)]  # Список B, проинициализированный элементами в интервале [0; 10)
C = [0] * 7                 # Список C, проинициализированный семью нулями

# Вывод списка
print('A =', A)
print('B =', B)
print('С =', C)
print()

# Длина списка
print('Длина списка A равна', len(A))
print('Длина списка B равна', len(B))
print('Длина списка C равна', len(C))
print()


print('-=-=-= ДОСТУП К ЭЛЕМЕНТАМ СПИСКА =-=-=-')

# Доступ к элементам списка производится по индексу с помощью оператора [].
# Важно! Индексы нумеруются начиная с НУЛЯ.
print('A[0] =', A[0])
print('A[4] =', A[4])
# Так же в питоне есть возможность обращаться к элементам списка с отрицательным индексом. В отличие от положительных
# индексов, которые нумеруют элементы списка слева на право, отрицательные индексы нумеруют их справа на лево.
#
# Положительные индексы  0  1  2  3  4
#                       [6, 4, 5, 8, 7]
# Отрицательные индексы -5 -4 -3 -2 -1
#
# Таким образом, чтобы вывести последний элемент списка необязательно знать его длину. Можно просто указать -1 индекс.
print('A[-1] =', A[-1])
print('A[-5] =', A[-5])
print()
# Так же стоит обратить внимание на то, что положительный индекс последнего элемента всегда меньше длины списка на
# единицу (потому, что нумерация индексов начинается с 0).


print('-=-=-= ДОБАВЛЕНИЕ ЭЛЕМЕНТА В СПИСОК =-=-=-')

print('A =', A)
A += [17]
print('A += [17]')
print('A =', A)
A = [15] + A
print('A = [15] + A')
print('A =', A)
print()
# Так же добаление элементов в список можно осуществлять с помощью функций append() и insert() которые описаны ниже.


print('-=-=-= ПЕРЕБОР ЭЛЕМЕНТОВ СПИСКА ЦИКЛОМ for =-=-=-')

# 1 Вариант - по индексу
print('for i in range(len(A)):')
for i in range(len(A)):
    A[i] += 1

print(A)
print()

# 2 Вариант - по значению
print('for a in A:')
for a in A:
    a += 1

print(A)
print()

# 3 Вариант - по значению и индексу с помощью функции enumerate()
print('for a in A:')
for i, a in enumerate(A):
    A[i] = a + 1

print(A)
print()

# Существенное отличие этих вариантов заключается в следующем:
# - В первом варианте перебираются индексы, с помощью которых осущетвляется доступ непосредственно к элементам списка.
#   Количество итераций цикла зависит от аргументов функции range(), и в данном случае соответствует количеству
#   элементов списка, определенного с помощью функции len(A). Так же индексы позволяют изменять значения элементов
#   списка. Например A[i] += 1 увеличит значение i-го элемента списка A на единицу.
# - Во втором варианте перебираются копии значений элементов списка. В данном случае количество итераций в цикле всегда
#   равно количеству элементов списка. В данном варианте невозможно изменить значения списка так как в цикле
#   перебираются копии элементов. Например, a += 1 увеличит на единицу значение копии, при этом значение элемента
#   списка останется неизменным.
#
# Эти факторы необходимо учитывать при переборе элементов списка. Если необходимо перебрать все элементы списка и
# изменение значений списка не требуется, тогда лучше воспользоваться вторым вариантом, т.к. он короче, выглядит
# элегантнее и не использует лишних переменных для хранения индекса.


print('-=-=-= СРЕЗЫ =-=-=-')

# Срез - это часть списка, определенная при помощи индексов. Работа со срезами очень похожа на операцию доступа к
# элементу списка по индексу, только в данном случае в квадратных скобках указываются <индекс начала среза>, <индекс
# конца среза> и <шаг>, разделенные двоеточием ':'. Шаг не является обязательным параметром и его можно не указывать.
# Если шаг не указан, то по умолчанию он равен единице.
print('A =', A)
print('A[1:4] =', A[1:4])
# Тут важно помнить одну особенность, что несмотря на то, что указан 4-й индекс как конец среза, он не будет включен
# в результирующий список. Здесь, так же как и в методе range() для цикла for действует следующее определение
# интервала: [1; 4).

# Если оставить пустым индекс начала, то срез будет браться от начала списка и до индекса конца.
print('A[:4] =', A[:4])
# Если оставить пустым индекс конца, то срез будет браться от индекса начала и до конца списка.
print('A[1:] =', A[1:])
# Если оставить пустыми оба индекса, то список будет выведен целиком.
print('A[:] =', A[:])

# Шаг среза
# Шаг среза определяет в каком порядке будут выводиться элементы списка: подряд (Шаг = 1), через один или каждый
# второй (Шаг = 2), через два или каждый третий (Шаг = 3)
print('A[::2] =', A[::2])
print('A[::3] =', A[::3])
# Если задать шаг отрицательным значением, то формирование среза будет осуществляться через отрицательные индексы,
# а значит - задом на перед.
print('A[::-1] =', A[::-1])
print()


print('-=-=-= МЕТОДЫ СПИСКОВ (ФУНКЦИИ) =-=-=-')

# Добавить элемент в конец списка
A.append(55)
print('A.append(55) => A =', A)
# Добавить элемент в список по заданному индексу
A.insert(4, 99)
print('A.insert(4, 99) => A =', A)
# Удаляет из списка первый элемент, значение которого равно аргументу функции
A.remove(99)
print('A.remove(99) => A =', A)
# Возвращает индекс первого элемента, значение которого равно аргументу функции
print('A.index(8) =>', A.index(8))
# Посчитать количество определенных элементов в списке
print('A.count(5) =>', A.count(5))
# Возвращает значение элемента по индексу и удаляет его из списка. Если индекс не указан - то удаляется
# последний элемент.
print('A.pop(1) =>', A.pop(0), '   A =', A)
# Располагает элементы списка в обратном порядке, НЕ СОРТИРУЕТ.
A.reverse()
print('A.reverse() => A =', A)
# Возвращает сортированную копию списка, не меняя при этом порядок элементов в самом списке.
print('sorted(A) =>', sorted(A, reverse=True), 'при этом A =', A)
# Сортирует список по возрастанию
A.sort()
print('A.sort() => A =', A)
# Сортирует список по убыванию
A.sort(reverse=True)
print('A.sort(reverse=True) =>', A)
# Добавляет в конец списка элементы другого списка
A.extend(B)
print('A.extend(B) =>', 'A =', A, 'при этом B =', B)
# Очищение списка
A.clear()
print('A.clear() => A =', A)
print()


print('-=-=-= КОПИРОВАНИЕ СПИСКОВ =-=-=-')

A = [1, 2, 3]
B = A
# Прямое присвоение переменной A в переменную B не создает копию списка А в переменной В, а кладет туда ссылку на
# переменную А. Таким образом, при изменении элементов переменной В, произойдут такие же изменения и в переменной А,
# так как они ссылаются на один и тот же список.
print('A =', A)
print('B = A => B =', B)
B.append(4)
print('B.append(4) =>', 'B =', B)
print('A =', A)
# Чтобы переменной B присвоить копию списка А необходимо использовать функцию copy(). В таком случае изменения
# элементов в переменной В никак не отразятся на переменной А.
B = A.copy()
print('B = A.copy() => B =', B)
B.append(5)
print('B.append(5) =>', 'B =', B)
print('A =', A)
print()


# Полезные функции для работы со списками

print('-=-=-= MAP =-=-=-')

# map() — это функция, которая позволяет обрабатывать и выполнять какие-либо действия со всеми элементами в итерируемом
# объекте без использования явного цикла for, методом, широко известным как сопоставление (mapping). map() полезен,
# когда вам нужно применить функцию преобразования к каждому элементу в коллекции или в массиве и преобразовать их в
# новый массив.

A = [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12], [13, 14, 15]]  # Двумерный массив (список списков)
print('A =', A)
m = map(sum, A)  # map() применяет функцию sum к каждому элементу списка A (элементы списка А тоже списки).
                 # Обратите внимание, что имя функции указывается без скобок.
print('m = map(sum, A) =>', m)  # Функция map() возвращает объект типа map object.
print('list(m) =', list(m))  # Чтобы прочитать объект map, его необходимо преобразовать к списку.
print()


print('-=-=-= FILTER =-=-=-')

# filter() — это функция, позволяющая отфильтровать элементы списка (или других итеррируемых объектов)
# по правилу, которое определяется с помощью функции или лямбды. Функция с правилом должна возвращать результат
# true или false, чтобы определить что делать с элементом - сохранить или отсеять.

A = [i for i in range(20)]  # список чисел [0; 20)
print('A =', A)

# Функция для фильтрации только четных элементов
def f(x):
    # if x % 2 == 0:
    #     return True
    # else:
    #     return False

    # Либо просто
    return x % 2 == 0

fA = filter(f, A)  # filter() применяет функцию f к каждому элементу списка A чтобы определить,
                   # включить ли его или отсеять. Обратите внимание, что имя функции указывается без скобок.
print('fA = filter(f, A) =>', fA)  # Функция filter() возвращает объект типа filter object.
print('list(fA) =', list(fA))  # Чтобы прочитать объект filterobject, его необходимо преобразовать к списку.

# Использование лямбды вместо функции
print('list(filter(lambda x: x % 2 == 0, A)) =>', list(filter(lambda x: x % 2 == 0, A)))
print()
