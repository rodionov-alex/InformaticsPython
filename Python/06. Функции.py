from typing import Callable, Any

print('-=-=-= ФУНКЦИИ =-=-=-')


# Функция в python - это объект, принимающий аргументы и возвращающий значение.
# Функция определяется с помощью инструкции def.
def summa(a, b):
    return a + b


print('summa(5, 7) =>', summa(5, 7))


# Инструкция return говорит, что нужно вернуть значение. В нашем случае функция возвращает сумму a и b.
# Функция необязательно должна заканчиваться инструкцией return, при этом она вернет значение None.
def empty_func():
    pass  # pass - означает ничего не делать. Используется т.к. тело функции не может быть пустым.


print('empty_func() =>', empty_func())
print()

print('-=-=-= АГРУМЕНТЫ ФУНКЦИИ =-=-=-')


# Функция может принимать произвольное количество аргументов или не принимать их вовсе.
# Также распространены функции с произвольным числом аргументов, функции с позиционными
# и именованными аргументами, обязательными и необязательными.

# Функция, у которой аргумент c является необязательным и по умолчанию равен 2. Необязательные аргументы могут
# быть объявлены только в конце списка аргументов.
def func(a, b, c=2):
    return a + b + c


print('func(1, 2) =>', func(1, 2))  # a = 1, b = 2, c = 2 (по умолчанию)
print('func(1, 2, 3) =>', func(1, 2, 3))
print('func(c=9, b=3, a=4) =>', func(c=9, b=3, a=4))  # явное задание аргументов функции
print()


# Функция также может принимать переменное количество позиционных аргументов, тогда перед именем ставится *.
def func(*args):
    return args


print('func(1, 2, 3, \'abc\') =>', func(1, 2, 3, 'abc'))
print('func() =>', func())
print('func(1) =>', func(1))
print()


# Как видно из примера, args - это кортеж из всех переданных аргументов функции, и с переменной можно работать
# также, как и с кортежем.

# Функция может принимать и произвольное число именованных аргументов, тогда перед именем ставится **.
def func(**kwargs):
    return kwargs


print('func(a=1, b=2, c=3) =>', func(a=1, b=2, c=3))
print('func() =>', func())
print('func(a=\'python\') =>', func(a='python'))
print()

# В переменной kwargs у нас хранится словарь, и с переменной можно работать также, как и со словарем.


print('-=-=-= РЕКУРСИЯ =-=-=-')


# Рекурсия - это вызов функции из неё же самой. То есть вызов в теле функции этой же функции.

# В качестве примера напишем рекурсивную функцию вычисления факториала.
# Факториал n! = 1 * 2 * 3 * ... * (n - 2) * (n - 1) * n
# Очевидно, что n! = n * (n - 1)!. На этом принципе и напишем нашу функцию.
def fact(n):
    if n == 1:
        return 1
    else:
        return n * fact(n - 1)


print('fact(7) =', fact(5))
print()

# Порядок вызова функций будет таким:
# fact(5) => fact(4) => fact(3) => fact(2) => fact(1) => 1 => 2 => 6 => 24 => 120
# Вызов функции fact(5) внутри вызовет fact(4), которая внутри вызовет fact(3), которая внутри вызовет fact(2),
# которая внутри вызовет fact(1) которая вернет результат 1. Потом в обратном порядке возвращаются результаты:
# вызов fact(1) вернет результат 1 в fact(2), тот в свою очередь вернет результат 2 в fact(3), fact(3) вернет
# результат 6 в fact(4), fact(4) вернет результат 24 в fact(5) и уже fact(5) вернет результат 120.
# Посмотрите под отладчиком как происходит вызов функций.


print('-=-=-= АНОНИМНЫЕ ФУНКЦИИ (lambda) =-=-=-')

# Анонимные функции могут содержать лишь одно выражение, но и выполняются они быстрее. Анонимные функции
# создаются с помощью инструкции lambda. Кроме этого, их необязательно присваивать переменной, как делали
# мы инструкцией def func().
print('(lambda x, y: x + y)(4, 3) => ', (lambda x, y: x + y)(4, 3))
print()

la_func = lambda x, y: x + y
print('la_func = lambda x, y: x + y')
print('la_func(1, 2) =>', la_func(5, 2))
print()

# Функции lambda, в отличие от обычной, не требуется инструкция return, она неявно в ней есть по умолчанию.
# А в остальном, она ведет себя точно так же как и обычная функция.
la_func = lambda *args: args
print('la_func = lambda *args: args')
print('la_func(1, 2, 3, 4) =>', la_func(1, 2, 3, 4))
