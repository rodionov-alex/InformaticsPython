from random import randint

print('-=-=-= Звёздочки для распаковки в аргументы функции =-=-=-')

# При вызове функции можно использовать оператор * для распаковки итерируемого объекта в аргументы вызова:

products = ['молоко', 'хлеб', 'сосиски', 'йогурт']
print(products)
print(products[0], products[1], products[2], products[3])
print(*products)

# Строка print(*products) передаёт все элементы списка products в вызов print() как отдельные аргументы,
# поэтому нам даже не нужно знать, сколько элементов в списке.

# Оператор ** делает что-то похожее, только с именованными аргументами. Он позволяет взять словарь с парами
# ключ-значение и распаковать его в именованные аргументы в вызове функции:

date_info = {'year': "2020", 'month': "05", 'day': "09"}
date = "{year}-{month}-{day}".format(**date_info)
print(date)

# Или например в функцию:
def get_time_in_seconds(hours, minutes, seconds):
    return hours * 3600 + minutes * 60 + seconds

t = {'seconds': 15, 'hours': 3, 'minutes': 21}
print(get_time_in_seconds(**t), 'секунд')
print()


print('-=-=-= Звёздочки для упаковки аргументов, переданных в функцию =-=-=-')

# При определении функции можно использовать *, чтобы собрать переменное количество позиционных аргументов,
# переданных в функцию. Эта функция имитирует бросок любого количества костей и возвращает сумму выпавших очков.
# Она принимает любое количество аргументов.
def roll(*dice):
    return sum(randint(1, d) for d in dice)

print("roll(20) = ", roll(20))
print("roll(6, 6) = ", roll(6, 6))
print("roll(6, 6, 6) = ", roll(6, 6, 6))

# Стандартные функции Python print() и zip() тоже принимают любое количество позиционных аргументов.
# Благодаря * мы можем написать свою функцию, работающую похожим образом.
