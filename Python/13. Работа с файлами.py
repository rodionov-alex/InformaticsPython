print('-=-=-= РАБОТА С ФАЙЛАМИ =-=-=-')

# Прежде, чем начать работать с файлом, его надо открыть. Сделать это можно с помощью функции open(). После работы
# с файлом его необходимо закрыть при помощи функции close(). Хотя в питоне закрывать файл не обязательно, я
# настоятельно рекомендую это делать, так как это освобождает ресурсы, веделенные системой на чтение файла, и
# является правилом хорошего тона в программировании.

# У функции open() есть много параметров, но нам пока важны лишь 3 аргумента:
# 1) ИМЯ ФАЙЛА. Путь к файлу может быть относительным (относительно файла python) или
#    абсолютным (полный путь к файлу).
# 2) РЕЖИМ открытия файла:
#       'r' - открытие на чтение (является значением по умолчанию).
#       'w' - открытие на запись, содержимое файла удаляется, если файла не существует, создается новый.
#       'x' - открытие на запись, если файла не существует, иначе исключение.
#       'a' - открытие на дозапись, информация добавляется в конец файла.
#       'b' - открытие в двоичном режиме.
#       't' - открытие в текстовом режиме (является значением по умолчанию).
#       '+' - открытие на чтение и запись
#    Режимы могут быть объединены, то есть, к примеру, 'rb' - чтение в двоичном режиме.
#    По умолчанию режим равен 'rt'.
# 3) encoding - кодировка, в которой нужно читать файл, нужна только в текстовом режиме чтения.

f = open('text_file.txt')
print('f = open(\'text_file.txt\') =>', f)

# Таким образом переменная f теперь ассоциирована с файлом text_file.txt:
# <_io.TextIOWrapper name='text_file.txt' mode='r' encoding='cp1251'>.
#
# IO - означает "ввод/вывод" (input/output), TextIOWrapper - обертка для ввода/вывода.
# Таким образом, если быть точным, переменная f представляетм собой специализированную обетку для работы
# с потоком ввода/вывода файла.

f.close()
print()

# После работы с файлом - закрываем его с помощью функции close(). Функцию close() допускается не использовать
# когда файл открывается с инструкцией with, в таком слуае он будет автоматически закрыт по выходу из нее.
# Настоятельно рекомендуется использовать именно такую форму записи при работе с файлами.

with open('text_file.txt') as f:
    print('with open(\'text_file.txt\') as f: =>', f)
    print()


print('-=-=-= СПОСОБЫ ЧТЕНИЯ ФАЙЛА =-=-=-')

# В python существует несколько способов чтения файла, рассмотрим основные из них.

# -= (1) =- При помощи функции read() можно считать весь файл целиком. Функция возвращает строку, в которой лежит
# текст всего файла.
with open('text_file.txt') as f:
    print('Чтение всего файла f.read():')
    s = f.read()
    print(s)

# При отладке этого кода обратите внимание на то, что в тексте строки s присутствуют экранные последовательности '\n',
# которые невидимы при выводе на экран. Именно благодаря им организуется переход на новую строку в тексте файла.

# -= (2) =- Файл можно считать построчно при помощи цикла for или функции readline().
with open('text_file.txt') as f:
    print('Чтение файла построчно с помощью цикла for:')
    for s in f:
        print(s, end='')

    print()

with open('text_file.txt') as f:
    print('Чтение файла построчно с помощью функции readline():')
    print(f.readline(), end='')
    print(f.readline(), end='')
    print(f.readline(), end='')
    print()

# Считывание файла построчно работает по определенному механизму. Чтобы проще его понять, можно представить
# что файл открыт в блокноте, а мигающая каретка установлена в начало файла. При считывании строки - каретка
# проходит по ней посимвольно пока не встретит экранную последовательность конца строки '\n'. После этого,
# пройденные символы включая '\n' сохраняются в виде строки, которая возвращается функцией readline() или
# присваивается в переменную s очередной итерации цикла for. При этом фактически картка остается в начале,
# уже следующей за считанной, строки. И уже дальнейшее считывание файла будет производиться не с начала файла,
# а с текущей позиции каретки. Этот момент хорошо иллюстрируется если сначала вызвать функцию readline(), а
# затем считать файл с помощью цикла for.

with open('text_file.txt') as f:
    print('Чтение файла построчно с помощью функции readline(), а затем с помощью цикла for:')
    print(f.readline(), end='')

    for s in f:
        print(s, end='')

    print()

# Как можно заметить, цикл for считывает файл не с начала, а с того места, где остановилась каретка после
# считывания строки функцией readline().

# -= (3) =- Далее рассмотрим вариант построчного считывания всего файла при помощи функции readlines(). В
# отличие от функции 'readline' (без s на конце), она считывает не одну строку, а сразу все, и возвращает их
# в виде списка строк. Так же как и в предыдущем случае - считывание начинается с текущей позиции каретки.

with open('text_file.txt') as f:
    print('Чтение всего файла с помощью функции readlines():')
    print(f.readlines())
    print()


print('-=-=-= ПРИЕМЫ СЧИТЫВАНИЯ ДАННЫХ ИЗ ФАЙЛА =-=-=-')

# Теперь рассмотрим разные приемы считывания числовых данных из файла.

# Данные в виде текста (как они есть)
with open('data_file.txt') as f:
    print('Данные в виде текста (как они есть)')
    print(f.readlines())
    print()

# Варианты считавания данных с преобразованием в целочисленные
with open('data_file.txt') as f:
    print('Построчное считавание с преобразованием в int')
    data = []

    for s in f:
        data.append(int(s))

    print(data)
    print()

with open('data_file.txt') as f:
    print('Построчное считавание с преобразованием в int (компактная запись)')
    data = [int(s) for s in f]
    print(data)
    print()

with open('data_file.txt') as f:
    print('Считавание с использованием функции map()')
    data = list(map(int, f))
    print(data)
    print()


print('-=-=-= КОДИРОВКА =-=-=-')
# Если файл содержит русские символы (кириллицу), то при открытии, функции open() нужно указать
# кодировку UTF-8, в которой ей надо читать файл.

print('open(\'rus_file.txt\').readline():')
print(open('rus_file.txt').readline())
print('open(\'rus_file.txt\', encoding=\'UTF-8\').readline():')
print(open('rus_file.txt', encoding='UTF-8').readline())
