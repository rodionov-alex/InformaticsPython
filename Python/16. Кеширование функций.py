# Кэширование – один из подходов, который при правильном использовании значительно ускоряет работу и снижает
# нагрузку на вычислительные ресурсы. В модуле стандартной библиотеки Python functools реализован декоратор
# @lru_cache, дающий возможность кэшировать вывод функций, используя стратегию Least Recently Used (LRU,
# «вытеснение давно неиспользуемых»). Это простой, но мощный метод, который позволяет использовать в коде
# возможности кэширования.

# Базовый принцип работы заключается в том, что результат вызова функции сохраняется в памяти. И при последующих
# вызовах функции с такими же аргументами, вместо выполнения функции, результат будет сразу браться из памяти. Это
# существенно сокращает время работы программы.

# Пример. Ниже написаны две функции:
# Функция is_simple(), которая определяет, является ли число простым. И рекурсивная функция divs_of_divs(), которая
# рекурсивно ищет все делители числа, делители его делителей и так далее... Очевидно, что для больших чисел функция
# divs_of_divs() рекурсивно будет вызываться очень много раз. Причем очень часто функция будет вызываться для чисел,
# которые уже считались ранее этой функцией, что существенно замедляет выполнение программы.
#
# К примеру для числа 10^7 функция выполняется около 2.25 секунд, но если включить кеширование, то время выполнения
# сокращается до 0.001 секунды. Поскольку для повторяющихся значений больше нет необходимости заново выполнять долгую
# рекурсивную функцию, то получаем огромный прирост производительности.

from functools import lru_cache
from time import time

def is_simple(n: int):
    if n == 2:
        return True
    if n % 2 == 0:
        return False
    for d in range(3, int(n ** 0.5) + 1, 2):
        if n % d == 0:
            return False
    return True

# Перед функцией divs_of_divs() написан декоратор @lru_cache(None), позволяющий включить кеширование. В качестве
# аргумента задается максимальный размер кеша, если задать None - то ограничений нет. Попробуйте выполнить программу
# с кешированием и без.
@lru_cache(None)  # если закомментировать эту строку, то скорость выполнения замедлится в разы
def divs_of_divs(n):
    divs = {1, n}  # по умолчанию делители: 1 и само число

    # Если число не простое
    if not is_simple(n):
        for d in range(2, int(n ** 0.5) + 1):
            if n % d == 0:
                # Добавить делитель d
                divs.add(d)
                # Добавить делители d
                divs = divs.union(divs_of_divs(d))
                # Добавить частное
                divs.add(n // d)
                # Добавить делители частного
                divs = divs.union(divs_of_divs(n // d))

    return divs


start = time()
print('divs_of_divs(10 ** 7):')
print(sorted(divs_of_divs(10 ** 7)))
print('Время выполения:', "{:.5f}".format(time() - start), 'секунд')
print()


# Похожий механизм кеширования можно организовать своими силами при помощи словаря. В качестве ключа будет выступать
# значение аргумента функции, а в качестве значения - результат работы функции.

cache_dict = dict()  # кеш

def divs_of_divs_with_cache(n):
    # Проверим есть ли уже закешированный результат
    if n in cache_dict.keys():
        return cache_dict[n]

    divs = {1, n}  # по умолчанию делители: 1 и само число

    # Если число не простое
    if not is_simple(n):
        for d in range(2, int(n ** 0.5) + 1):
            if n % d == 0:
                # Добавить делитель d
                divs.add(d)
                # Добавить делители d
                divs = divs.union(divs_of_divs_with_cache(d))
                # Добавить частное
                divs.add(n // d)
                # Добавить делители частного
                divs = divs.union(divs_of_divs_with_cache(n // d))

    cache_dict[n] = divs  # кеширование результата
    return divs

start = time()
print('divs_of_divs_with_cache(10 ** 7):')
print(sorted(divs_of_divs_with_cache(10 ** 7)))
print('Время выполения:', "{:.5f}".format(time() - start), 'секунд')
