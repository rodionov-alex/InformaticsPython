print('-=-=-= МНОЖЕСТВА =-=-=-')

# Множество (set) — это одна из ключевых структур данных в Python. Она представляет собой неупорядоченную
# коллекцию уникальных элементов. Класс set, в некоторой степени, соответствует математическому множеству. Многие
# широко используемые математические операции, применимые к множествам, существуют и в set. Часто вычисления,
# производимые над множествами, оказываются гораздо быстрее, чем альтернативные операции со списками. В результате
# для того, чтобы писать эффективный код, просто необходимо уметь пользоваться множествами.

m = {'a', 'b', 'c', 'd', 'd', 'd'}
print('m =', m, 'имеет тип', type(m))
print()

# Поскольку элементы множества уникальны, то повторяющиеся элементы при добавлении или инициализации удаляются.
# Этим свойством множества удобно пользоваться когда необходимо избавиться от дубликатов.

# Другой отличительной особенностью множества является неупорядоченность его элементов. Именно поэтому получить
# доступ к какому-либо элементу множества нельзя, например по индексу как в списке. Оператор m[1] приведет к ошибке.

# Однако есть возможность перебрать все элементы множества при помощи цикла for:
print('Перебор элементов множества m:')

for x in m:
    print(x)

print()

# Для случаев когда необходимо получить какой-то конкретный элемент множества - его можно сначала преобразовать в
# список, а потом достать из него необходимый элемент.
print('list(m)[0] =', list(m)[0])
print()

# Конструктору set можно передать любой итерируемый объект
a = set('hello')
print('a =', a)
b = set(['a', 'b', 'c', 'd', 'e', 'f'])
print('b =', b)
c = set(('a', 'b', 'c', 'd', 'e', 'e', 'f', 'f'))
print('c =', c)
# Порядок элементов неважен
d = set(['d', 'e', 'f', 'a', 'b', 'c'])
print('d =', d)
print()

# В одном множестве могут храниться значения разных типов
f = set(['a', True, 123])
g = {'a', True, 123, True, 123}
print('f =', f)
print('g =', g)
print('f == g =>', f == g)
print()
# В качестве элементов множества могут выступать типы: float, int, string, bool, tuple. А вот списки, словари,
# да и сами множества, в состав множеств включать нельзя.

# При помощи пустых фигурных скобок нельзя объявить пстое множество потому что так объявляется словарь.
# set() - это множество, а {} - это словарь
print('type({}) =', type({}))
print()


print('-=-=-= МЕТОДЫ МНОЖЕСТВ (ФУНКЦИИ) =-=-=-')

a = set()
print('a =', a)
# Добавление элемента (в данном случае строкового)
a.add('hello')
print('a.add(\'hello\') -> a =', a)
# Следующий код НЕ эквивалентен предыдущему. Метод update ожидает поступления итерируемого объекта, поэтому
# строка рассматривается как итерируемый объект, содержащий символы которые и добавляются в множество
a.update('hello')
print('a.update(\'hello\') -> a =', a)
# А тут в множество добавляются две строки, так как они размещены в списке
a.update(['hi', 'world'])
print('a.update([\'hi\', \'world\']) -> a =', a)
# Удаляет элемент из множества. Выдаст исключение, если такого элемента не существует.
a.remove('world')
print('a.remove(\'world\') ->', a)
# Удаляет элемент, если он находится в множестве
a.discard('hello')
print('a.discard(\'hello\') ->', a)
print()

a = {'a', 'b', 'c'}
b = {'b', 'c', 'd'}
print('a =', a, '\tb =', b)
print()

# Объединение
print('a.union(b) ->', a.union(b))
print('a.union(\'bcd\') =>', a.union('bcd'))  # принимает итерируемый объект и возвращает его объединение с a
# Объединение множеств так же можно записать с помощью оператора | (логическое или)
print('a | b =>', a | b)
# Результатом функции является новое множество, оригинальное множество при этом не изменяется. Чтобы изменилялось
# оригинальное множество следует вызывать функцию a.update(b) или оператор a |= b.
print()

# Прересечение
print('a.intersection(b) =>', a.intersection(b))  # возвращает пересечение множеств a и b
print('a.intersection(\'bcd\') =>', a.intersection('bcd'))  # возвращает пересечение итерируемого объекта с a
# Прересечение множеств так же можно записать с помощью оператора & (логическое и)
print('a & b =>', a & b)
# Результатом функции является новое множество, оригинальное множество при этом не изменяется. Чтобы изменилялось
# оригинальное множество следует вызывать функцию a.intersection_update(b) или оператор a &= b.
print()

# Отличие
print('a.difference(b) =>', a.difference(b))  # возвращает отличие множества a от b
# Результатом функции является новое множество, оригинальное множество при этом не изменяется. Чтобы изменилялось
# оригинальное множество следует вызывать функцию a.difference_update(b) или оператор a -= b.
print()

# Симмметричное отличие
print('a.symmetric_difference(b) =>', a.symmetric_difference(b))  # возвращает объединение отличий a от b и b от a
# Симмметричное отличие множеств так же можно записать с помощью оператора ^ (исключающее ИЛИ - xor)
print('a ^ b =>', a ^ b)
# Результатом функции является новое множество, оригинальное множество при этом не изменяется. Чтобы изменилялось
# оригинальное множество следует вызывать функцию a.symmetric_difference_update(b) или оператор a ^= b.
print()

# Очистить множество
a.clear()
print('a.clear() ->', a)
print()


print('-=-=-= КОПИРОВАНИЕ МНОЖЕСТВ =-=-=-')

a = {1, 2, 3}
b = a
# Прямое присвоение переменной a в переменную b не создает копию множества a в переменной b, а кладет туда ссылку на
# переменную a. Таким образом, при изменении элементов переменной b, произойдут такие же изменения и в переменной a,
# так как они ссылаются на одно то же множество.
print('a =', a)
print('b = a => b =', b, )
b.add(4)
print('b.add(4) =>', 'b =', b)
print('a =', a)
# Чтобы переменной b присвоить копию множества a необходимо использовать функцию copy(). В таком случае изменения
# элементов в переменной b никак не отразятся на переменной a.
b = a.copy()
print('b = a.copy() => b =', b)
b.add(5)
print('b.add(5) =>', 'b =', b)
print('a =', a)
print()
