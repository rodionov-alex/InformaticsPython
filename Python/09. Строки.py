print('-=-=-= СТРОКИ =-=-=-')

# Строка во многом очень похожа список, по сути это - список символов. Поэтому имеет схожие со списком
# функции и методы. Однако, класс строки имеет и свои собственные методы, отличные от списка.

s = ''             # Пустая строка
s = 'Привет мир!'  # Строка S, проинициализированная значением 'Привет мир!'

# Вывод строки
print('s =', s)
print()

# Длина строки
print('Длина строки S равна', len(s))
print()


print('-=-=-= СИМВОЛ СТРОКИ ПО ИНДЕКСУ =-=-=-')

# Поличить любой символ строки можно по индексу точно так же, как если бы мы работали со списком. Для этого
# используется опаератор []. Индексы в строке нумеруются так же как и в списке начиная с НУЛЯ.
print('s[3] =', s[3])
print('s[-1] =', s[-1])
print()


print('-=-=-= СРЕЗЫ =-=-=-')

# Срезы строк работают точно так же как и у списков.

print('s =', s)
print('s[1:4] =', s[1:4])
print('s[:4] =', s[:4])
print('s[1:] =', s[1:])
print('s[:] =', s[:])
print('s[::2] =', s[::2])
print()


print('-=-=-= ЭКРАНИРОВАННЫЕ ПОСЛЕДОВАТЕЛЬНОСТИ =-=-=-')

# Для полноценного представления структуры текста или его специфики нам нужны какие-то особые символы. Некоторые
# символы должны управлять курсором. Для таких целей и существуют экранированные последовательности.
s = 'слово_1\nслово_2\nслово_3'
print('Пример последовательности \'\\n\' между словами:')
print(s)
print()

s = 'qwerty\n'
print('s = \'', s, '\'', sep='')
print('При этом длина строки len(s) =', len(s))
print()

# Вот некоторые из наиболее часто встречаемых последовательностей:
# \\ - символ обратного слеша
# \' - символ одинарных кавычек
# \" - символ двойных кавычек
# \n - символ перевода на новую сторку
# \t - символ табуляции

# Если перед открывающей кавычкой стоит символ 'r' (в любом регистре), то механизм экранирования отключается.
print(r'В данном тексте \n отключены \t экранированные \\ последовательности.')
print('В данном тексте НЕ \n отключены \t экранированные \\ последовательности.')
print()


print('-=-=-= МЕТОДЫ СПИСКОВ (ФУНКЦИИ) =-=-=-')

s = '\n   Привет мир   \n'
print('s = \'', s, '\'', sep='')

# Strip
print('len(s) =', len(s))
s = s.strip()  # Убирает пробелы и символы \n с начала и с конца строки
print('s.strip() => s = \'', s, '\'', sep='')

# Подсчет количества определенных символов в строке
print('s.count(\'и\') =>', s.count('и'))
print()
# Индекс символа в строке
print('s.index(\'р\') =>', s.index('р'))  # Возвращает индекс начала подстроки в строке, начиная поиск слева
print('s.rindex(\'р\') =>', s.rindex('р'))  # Возвращает индекс начала подстроки в строке, начиная поиск справа
print('s.find(\'р\') =>', s.find('р'))  # Возвращает индекс начала подстроки в строке, начиная поиск слева
print('s.rfind(\'р\') =>', s.rfind('р'))  # Возвращает индекс начала подстроки в строке, начиная поиск справа
print()
# Замена подстроки
print('s.replace(\'и\', \'*\') =>', s.replace('и', '*'))  # Заменяет все найденные подстроки первого аргумента на второй
print('s.replace(\'и\', \'*\', 1) =>', s.replace('и', '*', 1))  # Заменяет только одну подстроку на вторую
print()
# Разделение строки
print('s.split(\'и\') =>', s.split('и'))  # Разделяет строку на подстроки по символу 'и'
print('s.split(\'и\', 1) =>', s.split('и', 1))  # Разделяет строку на подстроки по символу 'и' один раз
print('s.rsplit(\'и\', 1) =>', s.rsplit('и', 1))  # Разделяет строку на подстроки по символу 'и' один раз начиная справа
print()
# Заглавные и строчные буквы
print('s.upper() =>', s.upper())  # Возвращает строку, написанную только заглвавными буквами
print('s.lower() =>', s.lower())  # Возвращает строку, написанную только строчными буквами
print('s.isupper() =>', s.isupper())  # Возвращает истину, если все буквы в строке заглавные
print('s.islower() =>', s.islower())  # Возвращает истину, если все буквы в строке строчные
print('s.isspace() =>', s.isspace())  # Проверяет что строка состоит только из пробелов
print()
# Проверка начала и конца строки
print('s.startswith\'Пр\') =>', s.startswith('Пр'))  # Возвращает истину если строка начинается с указанной подстроки
print('s.endswith(\'ир\') =>', s.endswith('ир'))  # Возвращает истину если строка заканчивается указанной подстрокой
print()
# Форматирование сроки
sf = '{} + {} = {}'  # фигурными скобками задаются места вставки аргументов функции format() в строку
print('sf = \'', sf, '\'', sep='')
# Аргументы функции format() будут вставляться в строку последовательно в место каждой фигурной скобки
print('sf.format(6, 4, 10) =>', sf.format(6, 4, 10))
sf = '{1} + {0} = {2}'  # в фигурных скобках можно задать индексы аргументов функции
print('sf = \'', sf, '\'', sep='')
# Тогда при форматировании аргументы будут вставляться в порядке, указанном в фигурных скобках
print('sf.format(6, 4, 10) =>', sf.format(6, 4, 10))
print()
# Позиционирование текста
print(s.ljust(20), '|<= s.ljust(20)')  # Выравниевает текст по левому краю в пределах 20 символов
print(s.center(20), '|<= s.center(20)')  # Выравниевает текст по центру в пределах 20 символов
print(s.rjust(20), '|<= s.rjust(20)')  # Выравниевает текст по правому краю в пределах 20 символов
print()
# Добавить незначащие нули числу
bin_num = bin(10)[2:]
# Добавляет слева строки нули пока ее длина не будет равна 8
print('bin_num =', bin_num, '| bin_num.zfill(8) =>', bin_num.zfill(8))
print()
# JOIN
# Функция join склеивает массив строк в одну строку, при этом строка, у которой вызывается эта функция будет являться
# разделителем между элементами массива.
strs = ['Массив', 'строк', 'склеенный', 'join']
print('strs =', strs)
print('\'\'.join(strs) =>', ''.join(strs))
print('\' \'.join(strs) =>', ' '.join(strs))
print('\'@\'.join(strs) =>', '@'.join(strs))
print()
