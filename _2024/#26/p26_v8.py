"""
Поезд, в котором К мест (с номерами от 1 до К), следует по магистрали через M населенных пунктов. мест.
Дан список из N заявок на поездку, для каждой из которых известно, на какой станции пассажир собирается
садиться, а на какой — выходить. При посадке на некоторой станции контроллер отдает предпочтение тому
пассажиру, который едет дальше остальных, определяя место пассажира, как свободное с минимальным номером.
При этом сначала осуществляется высадка пассажиров, а затем посадка.
Определите, сколько пассажиров смогут добраться до пункта своего назначения и на скольких перегонах в
поезде будут заняты все места (перегон – это участок магистрали между соседними населенными пунктами).
Входные данные представлены в файле 26-126.txt следующим образом. Первая строка входного файла содержит
три натуральных числа: M (2 ≤ M ≤ 2000) – количество населенных пунктов со станциями на магистрали,
K (1 ≤ K ≤ 1000) – количество мест в поезде и N (1 ≤ N ≤ 10000) – количество пассажиров, желающих проехать
на поезде.
В каждой из последующих N строк располагаются пары чисел: сначала номер населенного пункта, откуда хочет
начать свою поездку пассажир, затем номер населенного пункта, где пассажир собирается сойти с поезда.
В ответе запишите два числа: количество пассажиров, которые смогут добраться до пункта своего назначения,
и количество перегонов, на которых в поезде будут заняты все места.
Пример входного файла::
10 3 6
2 6
2 4
3 5
3 8
4 9
4 6
При таких исходных данных добраться до нужного пункта смогут 4 пассажира ( (2, 6), (2, 4), (3, 8), (4, 9) ).
При этом свободных мест не будет на перегонах 3 перегонах (3-4, 4-5 и 5-6). Ответ: 4 3.

Ответ: 2873 267
"""

with open('Files/26-126.txt') as f:
    m, k, n = tuple(map(int, f.readline().split()))
    data = [tuple(map(int, x.split())) for x in f]
    train = [0] * k                 # список мест в поезде
    passangers = []                 # список пассажиров
    delivered = 0                   # количество пассажиров, которые добрались до пункта своего назначения
    completely_filled_count = 0     # количество перегонов, на которых в поезде будут заняты все места

    # Заполинм список пассажиров: сначала номер населенного пункта, откуда хочет начать свою поездку пассажир,
    # затем номер населенного пункта, где пассажир собирается сойти с поезда. Последним параметром является длина
    # поездки, умноженная на -1 (это нужно для дальнейшей сортировки).
    for get_in, get_out in data:
        passangers.append((get_in, get_out, -(get_out - get_in)))
    # Необходимо отсортировать пассажиров по станции отправления по возрастанию, а по длине поездки по убыванию.
    # Так как обновременно это сделать нельзя, именно с этой целью длина поездки и домножалась на -1, чтобы самые
    # большие числа длины поездки стали самыми маленькими отрицательными. Теперь можно просто отсортировать по
    # возрастанию по станции отправления и по длине поездки одновременно.
    passangers.sort(key=lambda x: (x[0], x[2]))
    # После сортировки пройдем по всем пассажирам и вернем длине поездки положительное значение
    for i in range(len(passangers)):
        get_in, get_out, trip_len = passangers[i]
        passangers[i] = (get_in, get_out, -trip_len)
    # Перебор всех станций
    for i in range(1, m + 1):
        # Высадка пассажиров, которые должны сойти на станции
        for j in range(k):
            if train[j] == i:
                # Освободить место в поезде
                train[j] = 0
                # Увеличить счетчик доставленных пассажиров
                delivered += 1
        # Посадка пассажиров
        while len(passangers) and passangers[0][0] == i:
            passanger = passangers.pop(0)
            # Если в поезде есть свободные места, то посадить пассажира в поезд
            if 0 in train:
                train[train.index(0)] = passanger[1]  # задать номер станции на которой место освободится
        # Если при отправлении со станции поезд полностью загружен, то увеличить счетчик количества перегонов.
        # С последней станции поезд никуда не поедет.
        if 0 not in train and i != m:
            completely_filled_count += 1

    print(delivered, completely_filled_count)
