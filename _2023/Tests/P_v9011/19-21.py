# Два игрока, Петя и Ваня, играют в следующую игру. Перед игроками лежат две кучи камней. Игроки ходят по очереди,
# первый ход делает Петя. За один ход игрок может добавить в одну из куч один камень или увеличить количество камней
# в куче в два раза. Чтобы делать ходы, у каждого игрока есть неограниченное количество камней. Игра завершается в
# тот момент, когда суммарное количество камней в кучах становится не менее 40. Победителем считается игрок, сделавший
# последний ход, т. е. первым получивший позицию, в которой в кучах будет 40 или больше камней.
# В начальный момент в первой куче было 9 камней, во второй куче – S камней, 1 ≤ S ≤ 30. Будем говорить, что игрок
# имеет выигрышную стратегию, если он может выиграть при любых ходах противника.
#
# Ответьте на следующие вопросы:
#
#   Вопрос 1. Известно, что Ваня выиграл своим первым ходом после неудачного первого хода Пети. Назовите минимальное
#   значение S, при котором это возможно.
#
#   Вопрос 2. Найдите два таких значения S, при которых у Пети есть выигрышная стратегия, причём Петя не может выиграть
#   первым ходом, но может выиграть своим вторым ходом независимо от того, как будет ходить Ваня. Найденные значения
#   запишите в ответе в порядке возрастания.
#
#   Вопрос 3. Сколько существует значений S, при которых у Вани есть выигрышная стратегия, позволяющая ему выиграть
#   первым или вторым ходом при любой игре Пети, и при этом у Вани нет стратегии, которая позволит ему гарантированно
#   выиграть первым ходом.
#
# Ответ: 4
#        3 14
#        0

# +1, *2
# win >= 40
# 9, 1 <= s <= 30

def f(a, b, p, m):
    if a + b >= 40:
        return p % 2 == m % 2
    elif p == m:
        return 0
    h = (f(a + 1, b, p + 1, m), f(a, b + 1, p + 1, m), f(a * 2, b, p + 1, m), f(a, b * 2, p + 1, m))
    return any(h) if (p + 1) % 2 == m % 2 else all(h)  # any(h)

for s in range(1, 31):
    for m in range(1, 5):
        if f(9, s, 0, m):
            # if m == 2:
            print(s, m)
            break
