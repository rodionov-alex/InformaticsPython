# Два игрока, Петя и Ваня, играют в следующую игру. Перед игроками лежит куча камней. Игроки ходят по очереди,
# первый ход делает Петя. За один ход игрок может уменьшить количество камней в три раза (количество камней,
# полученное при делении, округляется до меньшего) или убрать из кучи 10 камней. Например, из кучи из 25 камней
# можно получить кучу из 8 или 15 камней. Игра завершается в тот момент, когда количество камней в куче становится
# не более 10. Победителем считается игрок, сделавший последний ход. В начальный момент в куче было S камней (S ≥ 11).
#
# Ответьте на следующие вопросы:
#   Вопрос 1. Известно, что Ваня выиграл своим первым ходом после неудачного хода Пети. При каком максимальном
#   значении S такое возможно?
#
#   Вопрос 2. Найдите минимальное и максимальное значения S, при которых у Пети есть выигрышная стратегия, причём
#   Петя может выиграть своим вторым ходом независимо от того, как будет ходить Ваня. Найденные значения запишите
#   в ответе в порядке возрастания.
#
#   Вопрос 3. Сколько существует значений S, при которых Ваня имеет выигрышную стратегию за один или два хода, при
#   этом не имеет выигрышной стратегии в один ход?
#
# Ответ: 98
#        43 128
#        20

# /3, -10
# win <= 10
# s >= 11

from functools import lru_cache
import math as mt

def moves(a):
    return mt.floor(a / 3), a - 10


@lru_cache(None)
def game(h):
    if h <= 10:
        return 'w'
    if any(game(m) == 'w' for m in moves(h)):
        return 'p1'
    if all(game(m) == 'p1' for m in moves(h)):
        return 'v1'
    if any(game(m) == 'v1' for m in moves(h)):
        return 'p2'
    if all(game(m) == 'p1' or game(m) == 'p2' for m in moves(h)):
        return 'v2'


for s in range(11, 850):
    if game(s) is not None:
        print(s, game(s))

