# Два игрока, Петя и Ваня, играют в следующую игру. Перед игроками лежит куча камней. Игроки ходят по очереди,
# первый ход делает Петя. За один ход игрок может добавить в кучу один камень или увеличить количество камней
# в куче в два раза. Для того чтобы делать ходы, у каждого игрока есть неограниченное количество камней. Игра
# завершается в тот момент, когда количество камней в куче становится не менее 129. Победителем считается игрок,
# сделавший последний ход, т.е. первым получивший кучу из 129 или больше камней. В начальный момент в куче было
# S камней, 1 ≤ S ≤ 128.
#
# Ответьте на следующие вопросы:
#   Вопрос 1. Укажите такое значение S, при котором Петя не может выиграть за один ход, но при любом ходе Пети Ваня
#   может выиграть своим первым ходом.
#
#   Вопрос 2. Найдите два наименьших значения S, при которых у Пети есть выигрышная стратегия, причём Петя не может
#   выиграть за один ход, но может выиграть своим вторым ходом независимо от того, как будет ходить Ваня. Найденные
#   значения запишите в ответе в порядке возрастания.
#
#   Вопрос 3. Найдите минимальное значение S, при котором Ваня может выиграть первым или вторым ходом при любой игре
#   Пети, но у него нет стратегии, которая позволит ему гарантированно выиграть первым ходом. Если найдено несколько
#   значений S, в ответе запишите минимальное из них.
#
# Ответ: 64
#        32 63
#        62

# +1, *2
# win >= 129
# 1 <= S <= 128

# region cache method
from functools import lru_cache

def moves(a):
    return a + 1, a * 2

@lru_cache(None)
def game(h):
    if h >= 129:
        return 'w'
    if any(game(m) == 'w' for m in moves(h)):
        return 'p1'
    if all(game(m) == 'p1' for m in moves(h)):
        return 'v1'
    if any(game(m) == 'v1' for m in moves(h)):
        return 'p2'
    if all(game(m) == 'p1' or game(m) == 'p2' for m in moves(h)):
        return 'v2'

for s in range(1, 129):
    if game(s) is not None:
        print(s, game(s))
# endregion

print()

# region Kabanov method
def f(s, c, m):
    if s >= 129:
        return c % 2 == m % 2
    if c == m:
        return 0
    h = [f(s + 1, c + 1, m), f(s * 2, c + 1, m)]
    return any(h) if (c + 1) % 2 == m % 2 else all(h)

for s in range(1, 129):
    for m in range(1, 5):
        if f(s, 0, m) == 1:
            print(s, m)
            break
# endregion
