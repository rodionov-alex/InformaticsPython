# Семья М. собирается купить билеты на самолет, чтобы полететь на отдых. Они выбрали рейс с двухэтажным самолётом.
# Так как в составе семьи, помимо папы и мамы, имеется двое детей, билеты смотрят так, чтобы вся семья летела в
# одном ряду на соседних местах. Каждый из них боится высоты, поэтому оба места у окон должны быть уже заняты другими
# людьми. Места у окон считаются самые крайние места в каждом ряду (первое и последнее).
# Известно, какие места уже куплены (заняты). Найдите ряд с наибольшим номером, в котором можно забронировать
# подходящие места для всей семьи. Гарантируется, что есть хотя бы один ряд, удовлетворяющий этому условию. Ряды,
# информации о которых нет в списке бронирования, не учитываются.
# Входные данные представлены в файле 26-81.txt следующим образом. В первой строке входного файла записаны два числа,
# разделённые пробелом: N – количество занятых мест (натуральное число, не превышающее 20 000) и K – количество мест
# в каждом ряду самолета.
# Каждая из следующих N строк содержит три натуральных числа, не превышающих 100 000: номер этажа, номер ряда и номер
# занятого места в этом ряду.
# Запишите в ответе два числа: максимальный номер ряда, в котором оба места у окон уже заняты и можно забронировать
# четыре соседних места, и общее количество таких рядов.
# Пример входного файла:
# 7 6
# 1 50 2
# 2 23 1
# 1 50 6
# 1 1 1
# 2 30 5
# 2 23 6
# 1 1 6
# Для этих данных можно забронировать 4 соседних места в двух рядах: в 1-м ряду на 1-м этаже и в 23-м ряду на 2-м
# этаже. Ответ: 23 2.
#
# Ответ: 8330 122

with open('26-81.txt') as f:
    places_in_row = int(f.readline().split()[1])
    need_places = 4
    data = [tuple(map(int, x.split())) for x in f.readlines()]
    plane_1 = {}  # 1 этаж
    plane_2 = {}  # 2 этаж
    max_row = 0
    good_rows = 0

    # Перебор данных и заполнение словарей, где ключ это номер ряда, а ряд это список длиной places_in_row.
    # Ряд состоит из 0 и 1, где 0 - это свободное место, а 1 - занятое.
    for d in data:
        floor, row, place = d

        if floor == 1:
            if row not in plane_1.keys():
                plane_1[row] = [0] * places_in_row

            plane_1[row][place - 1] = 1
        else:
            if row not in plane_2.keys():
                plane_2[row] = [0] * places_in_row

            plane_2[row][place - 1] = 1

    # Проверка 1 этажа
    for r in plane_1.keys():
        row = plane_1[r]

        # Должны быть заняты только первое и последнее места
        if row[0] == 1 and row[-1] == 1 and sum(row[1:places_in_row - 1]) == 0:
            good_rows += 1
            max_row = max(max_row, r)

    # Проверка 2 этажа
    for r in plane_2.keys():
        row = plane_2[r]

        # Должны быть заняты только первое и последнее места
        if row[0] == 1 and row[-1] == 1 and sum(row[1:places_in_row - 1]) == 0:
            good_rows += 1
            max_row = max(max_row, r)

    print(max_row, good_rows)
