# На склад торговой базы поступают товары в ящиках, которые имеют стандартный размер и разный вес. Ящики
# размещаются в контейнерах, каждый из которых вмещает два пакета с суммарным весом не более D кг. Если
# при этом какие-то пакеты не удалось упаковать в контейнеры парами (из-за слишком большого веса), они
# размещаются по одному. Гарантируется, что вес каждого ящика не превышает D. Определите наибольшее
# количество контейнеров, в которые можно поместить по 2 ящика, и минимально возможный суммарный вес
# ящиков, которые размещаются по одному в контейнере.
# Входные данные представлены в файле 26-91.txt следующим образом. В первой строке записаны два числа,
# разделённые пробелом: N – количество товаров (1 ≤ N ≤ 100000) и D – суммарный допустимый вес товаров в
# контейнере (1 ≤ D ≤ 1000). В каждой из следующих N строк записано одно натуральное число: вес ящика,
# поступившего на склад.
# Запишите в ответе два целых числа: сначала наибольшее количество контейнеров, в которые можно поместить
# по 2 ящика, затем минимально возможный суммарный вес ящиков, которые размещаются по одному в контейнере.
# Пример входного файла::
# 10 130
# 60
# 52
# 63
# 55
# 59
# 83
# 54
# 81
# 57
# 61
# При таких исходных данных задачи в 4-х контейнерах будут пары товаров {63, 61}, {60, 59}, {55, 57} и
# {54, 52}, а товары {81} и {83} (общим весом 164 кг) помещаются в отдельных контейнерах. Ответ: 4 164.
#
# Ответ: 4937 42595

with open('26-91.txt') as f:
    max_weight = int(f.readline().split()[1])
    # Ящики по убыванию
    data = sorted([int(x) for x in f.readlines()], reverse=True)
    # Ящики по возрастанию
    data2 = sorted(data)

    containers_count = 0
    min_total_weight = 0
    containers_count_2 = 0
    min_total_weight_2 = 0

    # Алгоритм 1: подбор подходящего ящика для самого маленького
    while len(data):
        pack1 = data.pop()  # Достаем последний в списке, самый легкий ящик
        pack2 = 0
        space = max_weight - pack1  # Оставшийся доступный вес

        # Перебираем неподходящие ящики пока не встретим подходящий
        for i in range(len(data)):
            if data[i] <= space:
                pack2 = data.pop(i)
                break

        if pack2 != 0:
            containers_count += 1
        else:
            min_total_weight += pack1

    # Алгоритм 2: подбор подходящего ящика для самого большого
    while len(data2):
        pack1 = data2.pop()  # Достаем последний в списке, самый тяжелый ящик
        pack2 = 0
        space = max_weight - pack1  # Оставшийся доступный вес

        # Перебираем подходящие ящики пока не встретим неподходящий
        for i in range(len(data2)):
            if data2[i] > space:
                # Берем предыдущий, который подходит
                if i > 0:
                    pack2 = data2.pop(i - 1)
                break
        else:
            pack2 = data2.pop()

        if pack2 != 0:
            # Количество контейнеров с двумя ящиками
            containers_count_2 += 1
        else:
            # Вес одиноких ящиков
            min_total_weight_2 += pack1

    print(containers_count, min_total_weight)
    print(containers_count_2, min_total_weight_2)
