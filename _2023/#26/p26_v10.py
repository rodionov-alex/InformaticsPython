# Меню бургерной включает 1000 различных блюд, которым присвоены коды 0 до 999. В отчёте фиксируют время начала и
# окончания приготовления каждого заказа. Если запись о заказе некоторого блюда встретилась первый раз – это время
# начала приготовления; если второй раз, значит, он уже приготовлен (может случиться так, что некоторые заказы по
# каким-то причинам не были приготовлены). Готовить несколько блюд с одним номером одновременно нельзя.
# Входные данные представлены в файле 26-86.txt следующим образом. В первой строке входного файла записано
# натуральное число N (1 ≤ N ≤ 100 000) – общее количество строк с данными. В каждой из следующих N строках
# записана пара чисел, разделённых пробелом: время (в минутах от начала работы бургерной) и код блюда (0..999).
# Запишите в ответе два числа: максимальное количество заказов, приготовление которых закончилось в течение одного
# часа, и код блюда с наибольшей средней продолжительностью приготовления.
# Пример входного файла::
# 8
# 60 5
# 40 1
# 90 5
# 45 5
# 20 2
# 55 1
# 10 2
# 50 5
# Наибольшее количество заказов – три – было приготовлено за час времени от 10 до 70 (70 – 10 = 60), это есть
# часовой максимум. Блюдо с кодом 1 в среднем готовилась 55 – 40 = 15 минут, блюдо 2 готовилась 20 – 10 = 10 минут,
# а блюдо 5 – (30 + 5)/2 = 17,5 минут.
# Ответ: 3 5.
#
# Ответ:

with open('26-86.txt') as f:
    data = sorted([tuple(int(y) for y in x.split()) for x in f.readlines()[1:]])
    print(data)

    # cook_dic = {x[1]: [y[0] for y in data if y[1] == x[1]] for x in data}

    cook_dic = dict()

    for d in data:
        if d[1] in cook_dic.keys():
            cook_dic[d[1]].append(d[0])
        else:
            cook_dic[d[1]] = [d[0]]

    print(cook_dic)

    # count = 0
    # time_avgs = [0] * (max(cook_dic.keys()) + 1)
    #
    # for k in cook_dic.keys():
    #     # cook_dic[k].sort()
    #
    #     times = []
    #
    #     while len(cook_dic[k]) >= 2:
    #         time = cook_dic[k].pop(1) - cook_dic[k].pop(0)
    #
    #         if time <= 60:
    #             count += 1
    #
    #         times.append(time)
    #
    #     if len(times):
    #         time_avgs[k] = sum(times) / len(times)
    #
    # print(count, max(time_avgs))

