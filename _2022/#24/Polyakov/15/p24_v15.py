Текстовый файл 24-164.txt состоит не более чем из 10^6 символов и содержит только заглавные буквы латинского
алфавита (ABC…Z). Текст разбит на строки различной длины. Необходимо найти строку, содержащую самую длинную
цепочку стоящих подряд одинаковых букв. Если таких строк несколько, надо взять ту, которая в файле встретилась
раньше. Определите, какая буква встречается в этой строке чаще всего. Если таких букв несколько, надо взять ту,
которая стоит раньше в алфавите. Запишите в ответе эту букву, а затем – сколько раз она встречается во всем файле.

Пример. Исходный файл:
ZZQABA
ZALAAC
QRAQUT
В этом примере в первой и второй строках наибольшая длина цепочек одинаковых буквы равна 2 (ZZ в первой строке,
AA во второй), в третьей – 1. Берём первую строку, т.к. она находится в файле раньше. В этой строке чаще других
встречаются буквы Z и A (по 2 раза), выбираем букву A, т. к. она стоит раньше в алфавите. В ответе для этого примера
надо записать A6, так как во всех строках файла буква A встречается 6 раз.

from collections import Counter

with open('24-164.txt') as f:
    lines = f.readlines()
    lcount = len(lines)
    mi = 0          # Индекс строки с самой длинной цепочкой
    max_count = 0   # Длина самой длинной цепочки

    # Поиск строки с самой длинной цепочкой
    for i in range(lcount):
        lines[i] = lines[i].strip()
        max_chain = 0
        count = 1

        for j in range(1, len(lines[i])):
            if lines[i][j] == lines[i][j - 1]:
                count += 1
                max_chain = max(count, max_chain)
            else:
                count = 1

        if max_chain > max_count:
            max_count = max_chain
            mi = i

    # Поиск самой часто-встречающейся буквы

    # Способ 1
    dic = {}  # Словарь, в котором ключ - это буква, а значение - это количество в строке

    for c in lines[mi]:
        if c in dic:
            dic[c] += 1
        else:
            dic[c] = 1

    print(dic)
    # Для каждого элемента при сравнении в функции min будет вызвана функция из key.
    # То есть для каждого ключа в словаре dic будет вызвана функция dic.get(), а ключ будет аргументом функции.
    # Таким образом будет найден минимум среди значений, а не ключей.
    char1 = max(dic, key=dic.get)

    # Способ 2
    x = Counter(lines[mi]).most_common()
    print(x)
    char2 = x[0][0]

    # Результат
    print(char1, sum(s.count(char1) for s in lines))
    print(char2, sum(s.count(char2) for s in lines))

# Ответ: K36582