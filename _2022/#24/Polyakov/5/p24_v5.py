f = open("test.txt")
line = f.readline()
f.close()

linelen = len(line)  # Длина строки
maxlen = 0           # Максимальная длина цепочки
comb = 'KEGE'        # Комбинация для поиска
comb_count = 0       # Текущее количество комбинаций в цепочке

a = 0  # Длина цепочки до первой комбинации
b = 0  # Длина цепочки до второй комбинации
c = 0  # Длина цепочки до третьей комбинации

# Цикл перебирает все символы в строке до linelen - 3
# т.к. сравнивается по 4 символа: текущий + 3 следующих
for i in range(linelen - 3):
    # Сравнение среза из 4 символов с комбинацией
    if line[i:i + 4] == comb:
        comb_count += 1  # Инкремент количества комбинаций

    # Далее идет цепочка условий в следующем порядке.
    # Чем чаще должно выполняться условие - тем раньше оно проверяется.
    # Это нужно чтобы минимизировать лишние проверки условий, которые уже никогда не повторятся.

    # Текущее количество комбинаций равно 2
    if comb_count == 2:
        c += 1  # Инкремент длины цепочки до третьей коммбинации

        # Если это последняя итерация цикла, то нужно к длине C добавить 3
        if i == linelen - 4:
            c += 3

    # Текущее количество комбинаций больше 2.
    # Произошел разрыв цепочки т.к. наткнулись на третью комбинацию.
    # Происходит проверка текузей цепочки и сдвиг по комбинациям для поиска следующей цепочки.
    elif comb_count > 2:
        # Текущая длина цепочки равна сумме a, b и с и еще плюс 3 первых символа из комбинации ('KEG')
        curlen = a + b + c + 3

        # Сравнение с длиной самой длинной цепочки
        if maxlen < curlen:
            maxlen = curlen

        # Сброс текущего количества комбинаций до 2 и сдвиг a, b и c
        comb_count = 2
        a = b - 1  # a теперь равно b минус один символ (т.к. вторая комбинация входит в длину b)
        b = c      # b теперь равно c
        c = 1      # c теперь равно 1 (текущему символу)

    # Текущее количество комбинаций равно 0. Будет выполняться только до первой найденной комбинации.
    elif comb_count == 0:
        a += 1  # Инкремент длины цепочки до первой комбинации

    # Текущее количество комбинаций равно 1. Будет выполняться только до второй найденной комбинации.
    elif comb_count == 1:
        b += 1  # Инкремент длины цепочки до второй комбинации

# Длина последней цепочки равна сумме a, b и с плюс 3 последних символа из-за range(linelen - 3)
curlen = a + b + c + 3

# Сравнение с длиной самой длинной цепочки
if maxlen < curlen:
    maxlen = curlen

# Вывод результата
print(maxlen)
