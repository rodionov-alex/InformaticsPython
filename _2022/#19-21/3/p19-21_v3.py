# +1, *3
# 56 <= win <= 80
# 1 <= s <= 55

from functools import lru_cache

def moves(a):
    return a + 1, a * 3

@lru_cache(None)
def game(h):
    # Задача попасть в окно 56 <= win <= 80
    if 56 <= h <= 80:
        return 'W'
    # Если вышли за границу - то побеждает следующий игрок (P1)
    # Например если вызвать game(85), то петя уже победил по сути до своего первого хода
    if h > 80:
        return 'P1'
    # Если сделав ход получен результат 'W' то петя выйграл первым ходом
    if any(game(m) == 'W' for m in moves(h)):
        return 'P1'
    # Если сделав ход получен результат 'P1' то Петя подвел результат к тому, чтобы Ваня выйграл своим первым ходом
    if all(game(m) == 'P1' for m in moves(h)):
        return 'V1'
    # Если сделав ход получен результат 'V1' то Ваня подвел результат к тому, чтобы Петя выйграл своим вторым ходом
    if any(game(m) == 'V1' for m in moves(h)):
        return 'P2'
    # Если сделав ход получен результат 'P1' или 'P2' то Петя подвел результат к тому,
    # чтобы Ваня выйграл своим вторым ходом
    if all(game(m) == 'P1' or game(m) == 'P2' for m in moves(h)):
        return 'V2'

for s in range(1, 56):
    r = game(s)
    if r is not None:
        print(s, r)

# 7         (19 / 3 ~~ 7)
# 18, 53    (P2)
# 52        (V2)
